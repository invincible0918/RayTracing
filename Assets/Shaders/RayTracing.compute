// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "BruteForceTrace.cginc"
#include "BVHTrace.cginc"
#include "Shade.cginc"


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> destination;

float4x4 camera2World;
float4x4 cameraInverseProjection;
float4 pixelOffset;

// Add directional light
float4 directionalLight;
float4 directionalLightColor;

int width;
int height;

// Utilize BVH for optimization
// #define BRUTE_FORCE
#pragma multi_compile __ BRUTE_FORCE
#pragma multi_compile __ COSINE_SAMPLE

// Camera
Ray CreateCameraRay(float2 uv)
{
    float3 camWS = mul(camera2World, float4(0, 0, 0, 1)).xyz;
    float3 directionWS = mul(camera2World, mul(cameraInverseProjection, float4(uv, 1, 1))).xyz;
    directionWS = normalize(directionWS);

    return CreateRay(camWS, directionWS);
}

[numthreads(8, 8, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    _pixel = id.xy;
    //_pixel = id.x + id.y * 3.43121412313;

    // transform pixel from (0, 1) to (-1, 1)
    //float2 uv = float2(id.xy / float2(width, height)) * 2 - 1;

    // Anti-Aliasing
    // 射线地产生实际是用的每一片像素的中心位置，如果我们在每一个像素内做随机移动产生射线，是不是就能减少一些锯齿了呢
    float2 uv = float2((id.xy + pixelOffset.xy) / float2(width, height)) * 2 - 1;

    Ray ray = CreateCameraRay(uv);

    // Test current ray direction
    //destination[id.xy] = float4(ray.direction * 0.5 + 0.5, 1);

    // Sample the skybox by spherical coordinate system https://juejin.cn/post/6844903880141045773
    //float theta = acos(ray.direction.y) / -PI;
    //float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
    //destination[id.xy] = SkyboxTex.SampleLevel(sampler_SkyboxTex, float2(phi, theta), 0);

    // To debug skybox
    //destination[id.xy] = SkyboxCube.SampleLevel(_LinearClamp, ray.direction, 0);

    ////Trace and shade
    //RayHit hit = Trace(ray);
    //float3 col = Shade(ray, hit);
    //destination[id.xy] = float4(col, 1);
    //return;

    // Reflection
    float3 col = float3(0, 0, 0);
    for (int i = 0; i < 5; i++)
    {
#ifdef BRUTE_FORCE
        RayHit hit = BruteForceTrace(ray);
#else
        RayHit hit = BVHTrace(ray);
#endif
        // https://blog.selfshadow.com/publications/s2015-shading-course/#course_content
        col += ray.energy * Shade(ray, hit);
        if (!any(ray.energy))   // any(x): x!=0 return true
            break;
    }
    destination[id.xy] = float4(col, 1);    
}
