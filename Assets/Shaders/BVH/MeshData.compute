//#pragma use_dxc
#pragma kernel Calculate

#include "Constants.cginc"

// 1. 构造 AABB
ByteAddressBuffer indexBuffer;
ByteAddressBuffer vertexBuffer;
StructuredBuffer<uint> materialIndexBuffer;
RWStructuredBuffer<AABB> aabbBuffer;
RWStructuredBuffer<Triangle> triangleDataBuffer;
RWStructuredBuffer<uint> triangleIndexBuffer;

uniform int trianglesCount;

void LoadVertex(uint index, out float3 position, out float3 normal, out float3 tangent, out float2 uv)
{
	uint pi = index * 11 * 4; // index * (3[position.xyz] + 3[normal.xyz] + 3[tangent.xyz] + 2[uv.xy]) * 4[bytes]
	uint ni = pi + 3 * 4;
	uint ti = pi + 6 * 4;
	uint uvi = pi + 9 * 4;

	position = asfloat(vertexBuffer.Load3(pi));
	normal = asfloat(vertexBuffer.Load3(ni));
	tangent = asfloat(vertexBuffer.Load3(ti));
	uv = asfloat(vertexBuffer.Load2(uvi));
}

// 2. 计算 MortonCode
float3 encompassingAABBMin;
float3 encompassingAABBMax;
RWStructuredBuffer<uint> mortonCodeBuffer;

uint ExpandBits(uint v)
{
    v = (v * 0x00010001u) & 0xFF0000FFu;
    v = (v * 0x00000101u) & 0x0F00F00Fu;
    v = (v * 0x00000011u) & 0xC30C30C3u;
    v = (v * 0x00000005u) & 0x49249249u;
    return v;
}

uint MortonCode(float3 v)
{
    v.x = min(max(v.x * 1024.0f, 0.0f), 1023.0f);
    v.y = min(max(v.y * 1024.0f, 0.0f), 1023.0f);
    v.z = min(max(v.z * 1024.0f, 0.0f), 1023.0f);
    uint xx = ExpandBits((uint) v.x);
    uint yy = ExpandBits((uint) v.y);
    uint zz = ExpandBits((uint) v.z);
    return (xx * 4 + yy * 2 + zz);
}

[numthreads(THREADS_PER_BLOCK,1,1)]
void Calculate(uint id : SV_DispatchThreadID)
{
	if (id >= trianglesCount)
		return;

    // 读取顶点索引
	uint3 triIndex = indexBuffer.Load3(id * 3 * 4); // id * 3[triangle vertices] * 4[bytes]

    // 读取原始position
	float3 p0, n0, p1, n1, p2, n2, t0, t1, t2;
	float2 uv0, uv1, uv2;
	LoadVertex(triIndex.x, p0, n0, t0, uv0);
	LoadVertex(triIndex.y, p1, n1, t1, uv1);
	LoadVertex(triIndex.z, p2, n2, t2, uv2);

	// 1. 构造 AABB
	AABB aabb = aabbBuffer[id];

	aabb.min = float3(
		min(min(p0.x, p1.x), p2.x),
		min(min(p0.y, p1.y), p2.y),
		min(min(p0.z, p1.z), p2.z)
		);
	aabb.max = float3(
		max(max(p0.x, p1.x), p2.x),
		max(max(p0.y, p1.y), p2.y),
		max(max(p0.z, p1.z), p2.z)
		);

	aabbBuffer[id] = aabb;
	triangleIndexBuffer[id] = id;

	//// 2. 构造 三角面数据
	Triangle tri; 

	tri.point0 = p0;	
	tri.point1 = p1;
	tri.point2 = p2;
	tri.normal0 = n0;
	tri.normal1 = n1;
	tri.normal2 = n2;
	tri.tangent0 = t0;
	tri.tangent1 = t1;
	tri.tangent2 = t2;
	tri.uv0 = uv0;
	tri.uv1 = uv1;
	tri.uv2 = uv2;
	tri.materialIndex = materialIndexBuffer[id] ;

	triangleDataBuffer[id] = tri;

	// 2. 计算 MortonCode
	float3 center = (aabb.min + aabb.max) * 0.5;
	float3 normalized = (center - encompassingAABBMin) / (encompassingAABBMax - encompassingAABBMin);

	mortonCodeBuffer[id] = MortonCode(normalized);
}